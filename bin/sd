#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

# ========== Defaults & Env ==========
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

CONF_DIR="$XDG_CONFIG_HOME/smolit_dev"
STATE_DIR="$XDG_STATE_HOME/smolit_dev"
CACHE_DIR="$XDG_CACHE_HOME/smolit_dev"
LOG_DIR="$STATE_DIR/logs"
PID_DIR="$STATE_DIR/pids"

mkdir -p "$CONF_DIR" "$STATE_DIR" "$CACHE_DIR" "$LOG_DIR" "$PID_DIR"

ENV_FILE="${ENV_FILE:-$CONF_DIR/.env}"
[[ -f "$ENV_FILE" ]] && set -a && . "$ENV_FILE" && set +a

WORKSPACE="${WORKSPACE:-$PWD}"
OH_IMAGE="${OH_IMAGE:-openhands/supergateway:latest}"
OH_NAME="${OH_NAME:-sd_oh}"
OH_PORT="${OH_PORT:-3311}"
SEQ_PORT="${SEQ_PORT:-8811}"
MEM_PORT="${MEM_PORT:-8812}"
BRIDGE_PORT="${BRIDGE_PORT:-8815}"
LM_BASE_URL="${LM_BASE_URL:-http://127.0.0.1:1234/v1}"

# Permissions / Security
SD_BYPASS_PERMISSIONS="${SD_BYPASS_PERMISSIONS:-}"
SD_ALLOWED_TOOLS="${SD_ALLOWED_TOOLS:-sequential-thinking,memory-shared,memory,codex-bridge}"

BRIDGE_BIN="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/bridge.mjs"
POSTINSTALL_BIN="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/postinstall.mjs"

log()   { echo -e "\e[36m[sd]\e[0m $*"; }
warn()  { echo -e "\e[33m[sd warn]\e[0m $*" >&2; }
die()   { echo -e "\e[31m[sd err]\e[0m $*" >&2; exit 1; }

need()  { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }

pidfile() { echo "$PID_DIR/$1.pid"; }
is_running() { [[ -f "$(pidfile "$1")" ]] && kill -0 "$(cat "$(pidfile "$1")")" 2>/dev/null; }

start_bridge() {
  if lsof -iTCP:"$BRIDGE_PORT" -sTCP:LISTEN >/dev/null 2>&1; then
    warn "Bridge-Port $BRIDGE_PORT bereits belegt – überspringe Start."
    return 0
  fi
  log "Starte Bridge auf Port $BRIDGE_PORT (WORKSPACE=$WORKSPACE)…"
  nohup node "$BRIDGE_BIN" \
    --port "$BRIDGE_PORT" \
    --workspace "$WORKSPACE" \
    --allowed-tools "$SD_ALLOWED_TOOLS" \
    $( [[ -n "$SD_BYPASS_PERMISSIONS" ]] && echo "--dangerously-skip-permissions" ) \
    >>"$LOG_DIR/bridge.log" 2>&1 &

  echo $! >"$(pidfile bridge)"
  sleep 0.3
  curl -fsS "http://127.0.0.1:$BRIDGE_PORT/healthz" >/dev/null 2>&1 || warn "Bridge healthz nicht erreichbar (noch bootend?)"
}

stop_bridge() {
  if is_running bridge; then
    log "Stoppe Bridge (PID $(cat "$(pidfile bridge)") )…"
    kill "$(cat "$(pidfile bridge)")" 2>/dev/null || true
    rm -f "$(pidfile bridge)"
  fi
}

start_openhands() {
  need docker
  if docker ps --format '{{.Names}}' | grep -q "^${OH_NAME}\$"; then
    warn "OpenHands Container '$OH_NAME' läuft bereits."
    return 0
  fi
  log "Starte OpenHands ($OH_IMAGE) auf Ports GUI:$OH_PORT SEQ:$SEQ_PORT MEM:$MEM_PORT …"
  docker run -d --rm \
    --name "$OH_NAME" \
    --add-host host.docker.internal:host-gateway \
    -p "$OH_PORT:3311" -p "$SEQ_PORT:8811" -p "$MEM_PORT:8812" \
    -e LM_BASE_URL="$LM_BASE_URL" \
    -v "$WORKSPACE:/workspace" \
    "$OH_IMAGE" \
    >/dev/null
}

stop_openhands() {
  if docker ps --format '{{.Names}}' | grep -q "^${OH_NAME}\$"; then
    log "Stoppe OpenHands Container '$OH_NAME' …"
    docker rm -f "$OH_NAME" >/dev/null || true
  fi
}

open_browser() {
  local url="http://127.0.0.1:$OH_PORT"
  if command -v xdg-open >/dev/null 2>&1; then xdg-open "$url" >/dev/null 2>&1 || true; fi
  echo "GUI: $url"
}

health() {
  local ok=0
  for url in \
    "http://127.0.0.1:$OH_PORT" \
    "http://127.0.0.1:$SEQ_PORT/healthz" \
    "http://127.0.0.1:$MEM_PORT/healthz" \
    "http://127.0.0.1:$BRIDGE_PORT/healthz"
  do
    if curl -fsS "$url" >/dev/null 2>&1; then
      echo -e "  ✓ $url"
      ok=$((ok+1))
    else
      echo -e "  ✗ $url"
    fi
  done
  [[ $ok -ge 1 ]] || return 1
}

ports_doctor() {
  echo "Port-Check:"
  for p in "$OH_PORT" "$SEQ_PORT" "$MEM_PORT" "$BRIDGE_PORT"; do
    if lsof -iTCP:"$p" -sTCP:LISTEN >/dev/null 2>&1; then
      echo "  ✗ Port $p belegt:"
      lsof -iTCP:"$p" -sTCP:LISTEN | awk 'NR==1 || NR==2'
    else
      echo "  ✓ Port $p frei"
    fi
  done
}

project_init() {
  local cfg="$WORKSPACE/.claude/settings.json"
  mkdir -p "$WORKSPACE/.claude"
  if [[ -f "$cfg" ]]; then
    log "Settings vorhanden: $cfg"
  else
    cat >"$cfg" <<'JSON'
{
  "mcpServers": {
    "sequential-thinking": { "type": "sse", "url": "http://host.docker.internal:8811/sse" },
    "server-memory":       { "type": "sse", "url": "http://host.docker.internal:8812/sse" }
  }
}
JSON
    log "Minimal .claude/settings.json erzeugt."
  fi
}

mcp_status() {
  echo "MCP Status:"
  health || true
  if command -v claude >/dev/null 2>&1; then
    echo "Claude '/mcp' Ausgabe (gekürzt):"
    set +e
    claude -p "/mcp" --print 2>/dev/null | sed -n '1,40p'
    set -e
  else
    echo "(Hinweis) 'claude' CLI nicht gefunden – überspringe '/mcp'."
  fi
}

send_to_bridge() {
  local file="$1"
  [[ -f "$file" ]] || die "Datei nicht gefunden: $file"
  curl -fsS "http://127.0.0.1:$BRIDGE_PORT/run?file=/workspace${file#"$WORKSPACE"}" || die "Bridge-Aufruf fehlgeschlagen."
}

ensure_oh_dirs() {
  mkdir -p "$WORKSPACE/.openhands"
}

analyze() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/init_prompt.txt"
  if [[ ! -f "$f" ]]; then
    cat >"$f" <<'MD'
# GOAL
Analysiere das gesamte Repository (Code+Docs), identifiziere Probleme, TODOs, Sicherheits-/Robustheits-Punkte und erstelle eine priorisierte Aktionsliste mit konkreten Patches.

# CONTEXT
- Projekt: smolit_dev (sd) — OpenHands + MCP (SSE) + Claude Bridge
- Environment: Node>=18, Docker, LM_BASE_URL für Offline-LLMs

# DELIVERABLES
1) Kurzfazit & Risiken
2) Konkrete Patches (copy&paste) für CLI/Bridge/Postinstall
3) Follow-up Plan: Integration in Sprachassistent (va), Flowise, n8n

# OUTPUT
- Sei präzise, generiere nur überprüfbaren Code.
MD
  fi
  start_bridge
  send_to_bridge "$f"
}

sa_index() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/index_sprachassistent.txt"
  cat >"$f" <<'MD'
# TASK
Lies den Code & die Ordnerstruktur des Sprachassistent-Projekts.
- Baue eine stichwortartige Knowledge-Map (Module, Pfade, Haupt-Funktionen)
- Extrahiere offene TODOs/Fehler (inkl. Fundstelle)
- Speichere eine kompakte Übersicht (geeignet als README-Abschnitt)

# OUTPUT
<KNOWLEDGE_MAP>
...
</KNOWLEDGE_MAP>
<TODOS>
...
</TODOS>
MD
  start_bridge
  send_to_bridge "$f"
}

sa_test() {
  ensure_oh_dirs
  ( cd "$WORKSPACE" && if command -v pytest >/dev/null 2>&1; then pytest -q | tee ".openhands/test_report.txt"; else echo "pytest nicht installiert"; fi )
  local f="$WORKSPACE/.openhands/test_prompt.txt"
  cat >"$f" <<'MD'
# TASK
Analysiere die Testausgabe in /workspace/.openhands/test_report.txt.
- Fasse Fehlerursachen zusammen
- Erzeuge geordnete Fix-Vorschläge mit minimal-invasiven Patches

# OUTPUT
<TEST_SUMMARY>…</TEST_SUMMARY>
<PATCHES>…</PATCHES>
MD
  start_bridge
  send_to_bridge "$f"
}

sa_next() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/next_steps.txt"
  cat >"$f" <<'MD'
# TASK
Erzeuge aus vorhandenem Wissensstand (Memory, letzte Antworten) konkrete Next-Steps:
- 5–10 Aufgaben in Umsetzungreihenfolge
- Je Aufgabe: Ziel, betroffene Dateien, Kurz-Patch/Command

# OUTPUT
<NEXT_STEPS>…</NEXT_STEPS>
MD
  start_bridge
  send_to_bridge "$f"
}

deps_doctor() {
  echo "Dependencies:"
  for b in docker node npm curl; do
    if command -v "$b" >/dev/null 2>&1; then
      echo "  ✓ $b: $(command -v "$b")"
    else
      echo "  ✗ $b fehlt"
    fi
  done
}

usage() {
  cat <<USAGE
sd — One-command Dev-Stack (OpenHands + MCP + Bridge)

Usage:
  sd up              # Startet OpenHands + Bridge (GUI öffnet lokal)
  sd start           # wie 'up', ohne Browser-Open
  sd stop            # stoppt Container & Bridge
  sd status          # zeigt Health-Checks
  sd logs            # zeigt Logpfad
  sd deps doctor     # Dependency-Check
  sd ports doctor    # Port-Check

  sd project init    # erzeugt .claude/settings.json (MCP SSE)
  sd mcp status      # zeigt /healthz & ggf. 'claude -p "/mcp"'

  sd analyze         # schickt Analyse-Init-Prompt zur Bridge
  sd sa index        # indexiert Sprachassistent (Knowledge-Map)
  sd sa test         # pytest -> Zusammenfassung & Patches
  sd sa next         # nächste Schritte erzeugen

Env:
  ENV_FILE=$ENV_FILE
  WORKSPACE=$WORKSPACE
  Ports: OH=$OH_PORT SEQ=$SEQ_PORT MEM=$MEM_PORT BRIDGE=$BRIDGE_PORT
USAGE
}

cmd="${1:-help}"
shift || true
case "$cmd" in
  up)      start_openhands; start_bridge; open_browser ;;
  start)   start_openhands; start_bridge ;;
  stop)    stop_bridge; stop_openhands ;;
  status)  health || true ;;
  logs)    echo "$LOG_DIR" ;;
  deps)    sub="${1:-}"; shift || true; [[ "$sub" == "doctor" ]] && deps_doctor || usage ;;
  ports)   sub="${1:-}"; shift || true; [[ "$sub" == "doctor" ]] && ports_doctor || usage ;;
  project) sub="${1:-}"; shift || true; [[ "$sub" == "init" ]] && project_init || usage ;;
  mcp)     sub="${1:-}"; shift || true; [[ "$sub" == "status" ]] && mcp_status || usage ;;
  analyze) analyze ;;
  sa)      sub="${1:-}"; shift || true;
           case "${sub:-}" in
             index) sa_index ;;
             test)  sa_test ;;
             next)  sa_next ;;
             *)     usage ;;
           esac ;;
  help|--help|-h) usage ;;
  *) usage ;;
esac
