#!/usr/bin/env bash
# sd — One-command Dev-Stack (OpenHands + MCP + Claude-Bridge)
# Robust CLI for starting/stopping the stack, sending prompts, and repo-centric AI helpers.
set -Eeuo pipefail
IFS=$'\n\t'

# ===== Trap =====
cleanup() { :; }
trap cleanup EXIT

# ===== Colors =====
if [[ -t 1 ]]; then
  cCyan=$'\e[36m'; cYel=$'\e[33m'; cRed=$'\e[31m'; cDim=$'\e[2m'; cOff=$'\e[0m'
else
  cCyan=""; cYel=""; cRed=""; cDim=""; cOff=""
fi
log()   { echo -e "${cCyan}[sd]${cOff} $*"; }
warn()  { echo -e "${cYel}[sd warn]${cOff} $*" >&2; }
die()   { echo -e "${cRed}[sd err]${cOff} $*" >&2; exit 1; }
need()  { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }

# ===== XDG Paths =====
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

CONF_DIR="$XDG_CONFIG_HOME/smolit_dev"
STATE_DIR="$XDG_STATE_HOME/smolit_dev"
CACHE_DIR="$XDG_CACHE_HOME/smolit_dev"
LOG_DIR="$STATE_DIR/logs"
PID_DIR="$STATE_DIR/pids"

mkdir -p "$CONF_DIR" "$STATE_DIR" "$CACHE_DIR" "$LOG_DIR" "$PID_DIR"

ENV_FILE="${ENV_FILE:-$CONF_DIR/.env}"
[[ -f "$ENV_FILE" ]] && set -a && . "$ENV_FILE" && set +a

# ===== Core Env =====
WORKSPACE="${WORKSPACE:-$PWD}"
OH_IMAGE="${OH_IMAGE:-openhands/supergateway:latest}"
OH_NAME="${OH_NAME:-sd_oh}"
OH_PORT="${OH_PORT:-3311}"
SEQ_PORT="${SEQ_PORT:-8811}"
MEM_PORT="${MEM_PORT:-8812}"
BRIDGE_PORT="${BRIDGE_PORT:-8815}"
LM_BASE_URL="${LM_BASE_URL:-http://127.0.0.1:1234/v1}"
SD_LLM_MODEL="${SD_LLM_MODEL:-}"   # optional preferred model id

# Permissions / Security
SD_BYPASS_PERMISSIONS="${SD_BYPASS_PERMISSIONS:-}"
SD_ALLOWED_TOOLS="${SD_ALLOWED_TOOLS:-sequential-thinking,memory-shared,memory,codex-bridge}"

# ===== Binaries =====
SELF_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BRIDGE_BIN="$SELF_DIR/bridge.mjs"
POSTINSTALL_BIN="$SELF_DIR/postinstall.mjs"

# ===== Helpers =====
pidfile() { echo "$PID_DIR/$1.pid"; }
is_running() { [[ -f "$(pidfile "$1")" ]] && kill -0 "$(cat "$(pidfile "$1")")" 2>/dev/null; }

require_node18() {
  need node
  local major; major="$(node -p 'process.versions.node.split(".")[0]')" || true
  [[ "${major:-0}" -ge 18 ]] || warn "Node >= 18 empfohlen (gefunden: $(node -v))."
}

write_env_kv() {
  # idempotent key=val writer into $ENV_FILE
  local key="$1" val="$2"
  mkdir -p "$(dirname "$ENV_FILE")"
  touch "$ENV_FILE"
  if grep -qE "^${key}=" "$ENV_FILE"; then
    sed -i "s|^${key}=.*|${key}=${val//|/\\|}|" "$ENV_FILE"
  else
    printf "%s=%s\n" "$key" "$val" >> "$ENV_FILE"
  fi
}

ensure_oh_dirs() { mkdir -p "$WORKSPACE/.openhands"; }

# ===== Bridge =====
start_bridge() {
  require_node18
  if lsof -iTCP:"$BRIDGE_PORT" -sTCP:LISTEN >/dev/null 2>&1; then
    warn "Bridge-Port $BRIDGE_PORT bereits belegt – überspringe Start."
    return 0
  fi
  [[ -f "$BRIDGE_BIN" ]] || die "bridge.mjs nicht gefunden: $BRIDGE_BIN"
  log "Starte Bridge auf Port $BRIDGE_PORT (WORKSPACE=$WORKSPACE)…"
  nohup node "$BRIDGE_BIN" \
    --port "$BRIDGE_PORT" \
    --workspace "$WORKSPACE" \
    --allowed-tools "$SD_ALLOWED_TOOLS" \
    $( [[ -n "$SD_BYPASS_PERMISSIONS" ]] && echo "--dangerously-skip-permissions" ) \
    >>"$LOG_DIR/bridge.log" 2>&1 &
  echo $! >"$(pidfile bridge)"
  for _ in {1..20}; do
    sleep 0.2
    curl -fsS "http://127.0.0.1:$BRIDGE_PORT/healthz" >/dev/null 2>&1 && break || true
  done
}

stop_bridge() {
  if is_running bridge; then
    log "Stoppe Bridge (PID $(cat "$(pidfile bridge)") )…"
    kill "$(cat "$(pidfile bridge)")" 2>/dev/null || true
    rm -f "$(pidfile bridge)"
  fi
}

# ===== OpenHands =====
start_openhands() {
  need docker
  if docker ps --format '{{.Names}}' | grep -q "^${OH_NAME}\$"; then
    warn "OpenHands Container '$OH_NAME' läuft bereits."
    return 0
  fi
  log "Starte OpenHands ($OH_IMAGE) auf Ports GUI:$OH_PORT SEQ:$SEQ_PORT MEM:$MEM_PORT …"
  docker run -d --rm \
    --name "$OH_NAME" \
    --add-host host.docker.internal:host-gateway \
    -p "$OH_PORT:3311" -p "$SEQ_PORT:8811" -p "$MEM_PORT:8812" \
    -e LM_BASE_URL="$LM_BASE_URL" \
    -v "$WORKSPACE:/workspace" \
    "$OH_IMAGE" \
    >/dev/null
  for _ in {1..40}; do
    sleep 0.25
    curl -fsS "http://127.0.0.1:$OH_PORT" >/dev/null 2>&1 && break || true
  done
}

stop_openhands() {
  if docker ps --format '{{.Names}}' | grep -q "^${OH_NAME}\$"; then
    log "Stoppe OpenHands Container '$OH_NAME' …"
    docker rm -f "$OH_NAME" >/dev/null || true
  fi
}

open_browser() {
  local url="http://127.0.0.1:$OH_PORT"
  if command -v xdg-open >/dev/null 2>&1; then xdg-open "$url" >/dev/null 2>&1 || true; fi
  echo "GUI: $url"
}

# ===== Diagnostics =====
health() {
  local ok=0
  for url in \
    "http://127.0.0.1:$OH_PORT" \
    "http://127.0.0.1:$SEQ_PORT/healthz" \
    "http://127.0.0.1:$MEM_PORT/healthz" \
    "http://127.0.0.1:$BRIDGE_PORT/healthz"
  do
    if curl -fsS "$url" >/dev/null 2>&1; then
      echo -e "  ✓ $url"
      ok=$((ok+1))
    else
      echo -e "  ✗ $url"
    fi
  done
  [[ $ok -ge 1 ]] || return 1
}

ports_doctor() {
  echo "Port-Check:"
  for p in "$OH_PORT" "$SEQ_PORT" "$MEM_PORT" "$BRIDGE_PORT"; do
    if lsof -iTCP:"$p" -sTCP:LISTEN >/dev/null 2>&1; then
      echo "  ✗ Port $p belegt:"
      lsof -iTCP:"$p" -sTCP:LISTEN | awk 'NR==1 || NR==2'
    else
      echo "  ✓ Port $p frei"
    fi
  done
}

deps_doctor() {
  echo "Dependencies:"
  for b in docker node npm curl; do
    if command -v "$b" >/dev/null 2>&1; then
      echo "  ✓ $b: $(command -v "$b")"
    else
      echo "  ✗ $b fehlt"
    fi
  done
  if ! groups | grep -q '\bdocker\b'; then
    echo "  ${cDim}Hinweis:${cOff} Benutzer nicht in 'docker' Gruppe – ggf. 'sudo usermod -aG docker $USER' und neu anmelden."
  fi
}

# ===== MCP / Project =====
project_init() {
  local cfg="$WORKSPACE/.claude/settings.json"
  mkdir -p "$WORKSPACE/.claude"
  if [[ -f "$cfg" ]]; then
    log "Settings vorhanden: $cfg"
  else
    cat >"$cfg" <<'JSON'
{
  "mcpServers": {
    "sequential-thinking": { "type": "sse", "url": "http://host.docker.internal:8811/sse" },
    "server-memory":       { "type": "sse", "url": "http://host.docker.internal:8812/sse" }
  }
}
JSON
    log "Minimal .claude/settings.json erzeugt."
  fi
}

mcp_status() {
  echo "MCP Status:"
  health || true
  if command -v claude >/dev/null 2>&1; then
    echo "Claude '/mcp' (gekürzt):"
    set +e
    claude -p "/mcp" --print 2>/dev/null | sed -n '1,40p'
    set -e
  else
    echo "(Hinweis) 'claude' CLI nicht gefunden – überspringe '/mcp'."
  fi
}

# ===== Keys & LLM =====
keys_init() {
  mkdir -p "$(dirname "$ENV_FILE")"
  touch "$ENV_FILE"
  echo "API-Keys/URLs setzen (leer lassen zum Überspringen):"
  read -r -p "ANTHROPIC_API_KEY: " k1 || true
  read -r -p "LM_BASE_URL [${LM_BASE_URL}]: " k2 || true
  [[ -n "$k1" ]] && write_env_kv "ANTHROPIC_API_KEY" "$k1"
  [[ -n "$k2" ]] && write_env_kv "LM_BASE_URL" "$k2"
  echo "Gespeichert in: $ENV_FILE"
}

llm_list() {
  local url="$LM_BASE_URL/models"
  echo "Modelle von ${url}:"
  if command -v jq >/dev/null 2>&1; then
    curl -fsS "$url" | jq -r '
      (..|objects|select(has("id"))|.id) as $ids
      | (if type=="object" and has("data") then .data else . end)
      | (..|objects|select(has("id"))|.id) ' | sort -u
  else
    curl -fsS "$url" | tr -d '\n' | sed 's/"/\n/g' | grep -E '^[^[:space:]]+:[^[:space:]]+$' -m 0 || true
  fi
}

llm_use() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "Usage: sd llm use <model-id>"
  write_env_kv "SD_LLM_MODEL" "$id"
  echo "SD_LLM_MODEL=$id gesetzt (in $ENV_FILE)."
}

# ===== Bridge I/O =====
send_to_bridge_file() {
  local file="$1"
  [[ -f "$file" ]] || die "Datei nicht gefunden: $file"
  curl -fsS "http://127.0.0.1:$BRIDGE_PORT/run" \
    --get --data-urlencode "file=/workspace${file#"$WORKSPACE"}" \
    || die "Bridge-Aufruf fehlgeschlagen."
}

send_to_bridge_prompt() {
  local prompt="$1"
  [[ -n "${prompt:-}" ]] || die "Leerer Prompt."
  curl -fsS "http://127.0.0.1:$BRIDGE_PORT/run" \
    --get --data-urlencode "prompt=$prompt" \
    || die "Bridge-Aufruf fehlgeschlagen."
}

# ===== High-level Commands =====
analyze() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/init_prompt.txt"
  if [[ ! -f "$f" ]]; then
    cat >"$f" <<'MD'
# GOAL
Analysiere das gesamte Repository (Code+Docs), identifiziere Probleme, TODOs, Sicherheits-/Robustheits-Punkte und erstelle eine priorisierte Aktionsliste mit konkreten Patches.

# CONTEXT
- Projekt: smolit_dev (sd) — OpenHands + MCP (SSE) + Claude Bridge
- Environment: Node>=18, Docker, LM_BASE_URL für Offline-LLMs

# DELIVERABLES
1) Kurzfazit & Risiken
2) Konkrete Patches (copy&paste) für CLI/Bridge/Postinstall
3) Follow-up Plan für CI, Flowise, n8n

# OUTPUT
- Sei präzise, generiere nur überprüfbaren Code.
MD
  fi
  start_bridge
  send_to_bridge_file "$f"
}

cmd_index() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/index_repo.txt"
  cat >"$f" <<'MD'
# TASK
Lies Code & Struktur des aktuellen Repos.
- Erzeuge eine Knowledge-Map (Module, Pfade, Haupt-Funktionen, Datenflüsse)
- Liste offene TODOs/Fehler inkl. Fundstellen
- Eigne dich als kurzer README-Abschnitt

# OUTPUT
<KNOWLEDGE_MAP>…</KNOWLEDGE_MAP>
<TODOS>…</TODOS>
MD
  start_bridge
  send_to_bridge_file "$f"
}

cmd_test() {
  ensure_oh_dirs
  ( cd "$WORKSPACE" && if command -v pytest >/dev/null 2>&1; then pytest -q | tee ".openhands/test_report.txt"; else echo "pytest nicht installiert" | tee ".openhands/test_report.txt"; fi )
  local f="$WORKSPACE/.openhands/test_prompt.txt"
  cat >"$f" <<'MD'
# TASK
Analysiere die Testausgabe in /workspace/.openhands/test_report.txt.
- Fasse Fehlerursachen zusammen
- Erzeuge geordnete Fix-Vorschläge mit minimal-invasiven Patches (copy&paste)

# OUTPUT
<TEST_SUMMARY>…</TEST_SUMMARY>
<PATCHES>…</PATCHES>
MD
  start_bridge
  send_to_bridge_file "$f"
}

cmd_next() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/next_steps.txt"
  cat >"$f" <<'MD'
# TASK
Erzeuge konkrete Next-Steps basierend auf aktuellem Wissensstand (Memory & letzte Antworten):
- 5–10 Aufgaben in Reihenfolge
- Je Aufgabe: Ziel, betroffene Dateien, Kurz-Patch/Command

# OUTPUT
<NEXT_STEPS>…</NEXT_STEPS>
MD
  start_bridge
  send_to_bridge_file "$f"
}

# ===== Convenience / Shortcuts =====
cmd_init_repo() {
  # umbrella init for a fresh repo workspace
  project_init
  ensure_oh_dirs
  [[ -f "$WORKSPACE/.openhands/index_repo.txt" ]] || : > "$WORKSPACE/.openhands/index_repo.txt"
  log "Repo initialisiert: .claude/settings.json & .openhands/"
}

start_repl() {
  start_bridge
  echo "sd REPL — sende Zeilen an Bridge. Befehle: :quit, :help, :file <path>"
  while IFS= read -r -e line; do
    case "$line" in
      ":quit"|":q") break ;;
      ":help") echo ":file <path> — sendet Dateiinhalt /workspace relativ"; continue ;;
      ":file "*) f="${line#:file }"; [[ -f "$f" ]] || { echo "Datei fehlt: $f"; continue; }
                 send_to_bridge_file "$(realpath "$f")"; continue ;;
      "") continue ;;
      *) send_to_bridge_prompt "$line" ;;
    esac
  done
}

send_init() {
  local text="${*:-}"
  [[ -n "$text" ]] || die "Usage: sd send init \"GOAL: …\""
  start_bridge
  send_to_bridge_prompt "$text"
}

send_change() {
  local text="${*:-}"
  [[ -n "$text" ]] || die "Usage: sd send c \"Bitte ändere …\""
  start_bridge
  send_to_bridge_prompt "$text"
}

# ===== Usage =====
usage() {
  cat <<USAGE
sd — One-command Dev-Stack (OpenHands + MCP + Bridge)

Usage:
  sd up               # Stack im Hintergrund + Browser öffnen (GUI)
  sd start            # Stack starten (ohne Browser)
  sd stop             # Stack stoppen (Bridge + OpenHands)
  sd status           # Health-Checks
  sd logs             # Log-Verzeichnis anzeigen
  sd deps doctor      # Dependency-Check
  sd ports doctor     # Port-Check

  sd project init     # .claude/settings.json (MCP SSE) erzeugen
  sd init             # Projekt-Setup (.claude + .openhands) anlegen
  sd mcp status       # MCP-Status (healthz + ggf. 'claude -p "/mcp"')

  sd analyze          # Repo-Analyse starten
  sd index            # aktuelles Repo indexieren (Knowledge-Map)
  sd test             # Tests laufen lassen + Patch-Vorschläge
  sd next             # nächste Schritte erzeugen

  sd keys init        # API-Keys setzen (optional)
  sd llm list         # Modelle aus LM Studio anzeigen
  sd llm use <id>     # bevorzugtes Modell merken (SD_LLM_MODEL)

  sd start-repl       # interaktive Session (GUI parallel nutzbar)
  sd send init "…"    # einen Initial-/Ziel-Prompt an Bridge senden
  sd send c    "…"    # einen Änderungs-/Follow-up-Prompt senden
  sd c "…"            # Kurzform für 'sd send c …'

Env:
  ENV_FILE=$ENV_FILE
  WORKSPACE=$WORKSPACE
  Ports: OH=$OH_PORT SEQ=$SEQ_PORT MEM=$MEM_PORT BRIDGE=$BRIDGE_PORT
USAGE
}

# ===== Dispatcher =====
cmd="${1:-help}"; shift || true
case "$cmd" in
  up)            start_openhands; start_bridge; open_browser ;;
  start)         start_openhands; start_bridge ;;
  stop)          stop_bridge; stop_openhands ;;
  status)        health || true ;;
  logs)          echo "$LOG_DIR" ;;
  deps)          sub="${1:-}"; shift || true; [[ "${sub:-}" == "doctor" ]] && deps_doctor || usage ;;
  ports)         sub="${1:-}"; shift || true; [[ "${sub:-}" == "doctor" ]] && ports_doctor || usage ;;
  project)       sub="${1:-}"; shift || true; [[ "${sub:-}" == "init" ]] && project_init || usage ;;
  init)          cmd_init_repo ;;
  mcp)           sub="${1:-}"; shift || true; [[ "${sub:-}" == "status" ]] && mcp_status || usage ;;
  analyze)       analyze ;;
  index)         cmd_index ;;
  test)          cmd_test ;;
  next)          cmd_next ;;
  keys)          sub="${1:-}"; shift || true; [[ "${sub:-}" == "init" ]] && keys_init || usage ;;
  llm)           sub="${1:-}"; shift || true; case "${sub:-}" in list) llm_list ;; use) llm_use "${1:-}";; *) usage ;; esac ;;
  start-repl)    start_repl ;;
  send)          sub="${1:-}"; shift || true;
                 case "${sub:-}" in
                   init) send_init "$@";;
                   c)    send_change "$@";;
                   *)    [[ -n "${sub:-}" ]] && send_to_bridge_prompt "$sub $*" || usage ;;
                 esac ;;
  c)             send_change "$@" ;;
  help|--help|-h) usage ;;
  *)             usage ;;
esac
