#!/usr/bin/env bash
# ==============================================================================
#  sd  —  smolit_dev CLI
#  One-command Dev-Stack: OpenHands (Docker) + MCP (SSE) + Claude & Codex Bridge
#  Features:
#    • sd up / start / stop / status / logs [-f] / ports doctor / deps {install,install-global,doctor}
#    • sd project init / sd init / sd mcp status
#    • sd analyze / sd index / sd test / sd next
#    • sd keys init / sd llm {list,use <id>}
#    • sd start-repl / sd send init "…" / sd send c "…" / sd c "…"
#  Requirements: bash, docker, node>=18, curl (jq optional)
#  Cross-platform: Linux, macOS; Windows via Node-Launcher + Git Bash
# ==============================================================================

set -Eeuo pipefail
IFS=$'\n\t'

# ===== Colors =====
if [[ -t 1 ]]; then
  cCyan=$'\e[36m'; cYel=$'\e[33m'; cRed=$'\e[31m'; cDim=$'\e[2m'; cOff=$'\e[0m'
else
  cCyan=""; cYel=""; cRed=""; cDim=""; cOff=""
fi
log()   { echo -e "${cCyan}[sd]${cOff} $*"; }
warn()  { echo -e "${cYel}[sd warn]${cOff} $*" >&2; }
die()   { echo -e "${cRed}[sd err]${cOff} $*" >&2; exit 1; }
need()  { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }

# ===== Banner =====
banner() {
  cat <<'BANNER'
  ____     __  __    ____     _        ___    _____        
 / ___|   |  \/  |  / __ \   | |      |_ _|  |_   _|
 \___ \   | |\/| | | |  | |  | |       | |     | |
  ___) |  | |  | | | |__| |  | |___    | |     | |
 |____/   |_|  |_|  \____/   |_____|  |___|    |_|    _dev

OpenHands + MCP + Claude & Codex Bridge
repo helpers: analyze/index/test/next
send/init/repl • keys/llm • ports/deps • project/init
BANNER
}

# ===== Trap =====
cleanup() { :; }
trap cleanup EXIT

# ===== XDG Paths =====
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

CONF_DIR="$XDG_CONFIG_HOME/smolit_dev"
STATE_DIR="$XDG_STATE_HOME/smolit_dev"
CACHE_DIR="$XDG_CACHE_HOME/smolit_dev"
LOG_DIR="$STATE_DIR/logs"
PID_DIR="$STATE_DIR/pids"
mkdir -p "$CONF_DIR" "$STATE_DIR" "$CACHE_DIR" "$LOG_DIR" "$PID_DIR"

ENV_FILE="${ENV_FILE:-$CONF_DIR/.env}"
[[ -f "$ENV_FILE" ]] && set -a && . "$ENV_FILE" && set +a

# ===== Core Env (overridable via .env) =====
WORKSPACE="${WORKSPACE:-$PWD}"
WORKSPACE_DEFAULT="${WORKSPACE_DEFAULT:-$HOME/OpenHands_Workspace}"

LM_BASE_URL="${LM_BASE_URL:-http://127.0.0.1:1234/v1}"
OH_PORT="${OH_PORT:-3311}"
SEQ_PORT="${SEQ_PORT:-8811}"
MEM_PORT="${MEM_PORT:-8812}"
BRIDGE_PORT="${BRIDGE_PORT:-8815}"
MEM_FILE="${MEM_FILE:-$HOME/.mcp/memory/memory_shared.json}"

OH_IMAGE="${OH_IMAGE:-openhands/supergateway:latest}"
OH_NAME="${OH_NAME:-sd_oh}"
SD_LLM_MODEL="${SD_LLM_MODEL:-}"   # optional preferred model id

# Permissions / Security
SD_BYPASS_PERMISSIONS="${SD_BYPASS_PERMISSIONS:-}"      # set non-empty to allow dangerous perms
SD_ALLOWED_TOOLS="${SD_ALLOWED_TOOLS:-sequential-thinking,memory-shared,memory,codex-bridge}"

# ===== Binaries =====
SELF_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BRIDGE_BIN="$SELF_DIR/bridge.mjs"
POSTINSTALL_BIN="$SELF_DIR/postinstall.mjs"

# Prompt Templates
TEMPLATE_DIR="${SD_TEMPLATE_DIR:-$SELF_DIR/../templates}"

# ===== OS detection & portability helpers =====
OS_UNAME="$(uname -s 2>/dev/null || echo Unknown)"

# BSD sed (macOS) braucht -i ''
SED_INPLACE=(-i)
if [[ "$OS_UNAME" == "Darwin" ]]; then SED_INPLACE=(-i ''); fi

# realpath Fallback
_realpath() {
  if command -v realpath >/dev/null 2>&1; then
    realpath "$1"
  elif command -v python3 >/dev/null 2>&1; then
    python3 - "$1" <<'PY'
import os,sys; print(os.path.abspath(sys.argv[1]))
PY
  else
    (
      cd "$(dirname -- "$1")" >/dev/null 2>&1 || exit 1
      printf '%s/%s\n' "${PWD}" "$(basename -- "$1")"
    )
  fi
}

# open URL cross-platform
_open_url() {
  local url="$1"
  if command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$url" >/dev/null 2>&1 || true
  elif [[ "$OS_UNAME" == "Darwin" ]] && command -v open >/dev/null 2>&1; then
    open "$url" >/dev/null 2>&1 || true
  elif command -v cmd.exe >/dev/null 2>&1; then
    cmd.exe /c start "" "$url" >/dev/null 2>&1 || true
  else
    echo "Open: $url"
  fi
}

# Ports: lsof -> ss -> netstat Fallback
_port_in_use() {
  local port="$1"
  if command -v lsof >/dev/null 2>&1; then
    lsof -iTCP:"$port" -sTCP:LISTEN >/dev/null 2>&1
  elif command -v ss >/dev/null 2>&1; then
    ss -lntH "( sport = :$port )" 2>/dev/null | grep -q .
  elif command -v netstat >/dev/null 2>&1; then
    netstat -an 2>/dev/null | grep -E "[\.\:]$port[[:space:]]" | grep -qi LISTEN
  else
    return 1
  fi
}

_port_info() {
  local port="$1"
  if command -v lsof >/dev/null 2>&1; then
    lsof -iTCP:"$port" -sTCP:LISTEN | awk 'NR==1 || NR==2'
  elif command -v ss >/dev/null 2>&1; then
    ss -lntp "( sport = :$port )" 2>/dev/null | sed -n '1,2p'
  elif command -v netstat >/dev/null 2>&1; then
    netstat -an 2>/dev/null | grep -E "[\.\:]$port[[:space:]]" | sed -n '1,2p'
  fi
}

# ===== Helpers =====
pidfile() { echo "$PID_DIR/$1.pid"; }
is_running() { [[ -f "$(pidfile "$1")" ]] && kill -0 "$(cat "$(pidfile "$1")")" 2>/dev/null; }

require_node18() {
  need node
  local major; major="$(node -p 'process.versions.node.split(".")[0]')" || true
  [[ "${major:-0}" -ge 18 ]] || warn "Node >= 18 empfohlen (gefunden: $(node -v))."
}

write_env_kv() {
  local key="$1" val="$2"
  mkdir -p "$(dirname "$ENV_FILE")"; touch "$ENV_FILE"
  if grep -qE "^${key}=" "$ENV_FILE"; then
    local esc="${val//\//\\/}"
    sed "${SED_INPLACE[@]}" "s|^${key}=.*|${key}=${esc}|" "$ENV_FILE"
  else
    printf "%s=%s\n" "$key" "$val" >> "$ENV_FILE"
  fi
}

WORKSPACE="${WORKSPACE:-/workspace}"
OH_DIR="$WORKSPACE/.openhands"
MICRO_DIR="$OH_DIR/microagents"
PROMPTS_DIR="$OH_DIR/prompts"

mkdir -p "$MICRO_DIR" "$PROMPTS_DIR"

# --- ensure_oh_dirs: sorgt für .openhands Struktur + repo.md (auto) ---
ensure_oh_dirs() {
  mkdir -p "$MICRO_DIR" "$PROMPTS_DIR" "$OH_DIR/logs"
  if [[ ! -f "$MICRO_DIR/repo.md" ]]; then
    cat >"$MICRO_DIR/repo.md" <<'MD'
# Repo Microagent Context (repo.md)
<repo>
  <name>{{PROJECT}}</name>
  <root>{{WORKSPACE}}</root>
  <langs>python, typescript, bash</langs>
  <build>npm/yarn + uvicorn/pytest</build>
  <constraints>
    - keine Platzhalter, lauffähiger Code
    - backward-compatible, keine destructive ops ohne Backup
  </constraints>
  <contacts>
    - owner: huckle lab
  </contacts>
</repo>
MD
    # Platzhalter ersetzen
    local proj="$(basename "$WORKSPACE")"
    local w_esc="$(printf '%s' "$WORKSPACE" | sed -e 's/[\/&]/\\&/g')"
    sed ${SED_INPLACE[@]} \
      -e "s|{{PROJECT}}|$proj|g" \
      -e "s|{{WORKSPACE}}|$w_esc|g" \
      "$MICRO_DIR/repo.md"
    log "Auto: .openhands/microagents/repo.md erzeugt."
  fi
}


tail_logs() {
  echo "Logs in: $LOG_DIR"
  echo "Docker logs ($OH_NAME) und bridge.log folgen (Ctrl-C beendet)…"
  { docker logs -f "$OH_NAME" 2>&1 & echo $! >"$(pidfile dockerlogs)"; } || true
  tail -n 200 -F "$LOG_DIR/bridge.log" || true
  kill "$(cat "$(pidfile dockerlogs)" 2>/dev/null)" 2>/dev/null || true
  rm -f "$(pidfile dockerlogs)" || true
}

# == In bin/sd: Unter den Portability Helpers ergänzen ==
_escape_sed() { printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'; }

_render_template() {
  # _render_template <template-name> <dest-file>
  local name="$1"; local dest="$2"
  local src="$TEMPLATE_DIR/$name"
  mkdir -p "$(dirname "$dest")"
  if [[ ! -f "$src" ]]; then
    # Fallback-Minis, falls Template fehlt (keine Inline-Großprompts mehr)
    echo "# ${name%.*} — {{PROJECT}} @ {{DATE_ISO}}" > "$dest"
  else
    cp "$src" "$dest"
  fi
  local proj="$(basename "$WORKSPACE")"
  local now="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  # Platzhalter ersetzen (BSD/macOS-kompatibel via SED_INPLACE)
  local w_esc="$(_escape_sed "$WORKSPACE")"
  local l_esc="$(_escape_sed "$LM_BASE_URL")"
  sed "${SED_INPLACE[@]}" \
    -e "s|{{PROJECT}}|$proj|g" \
    -e "s|{{WORKSPACE}}|$w_esc|g" \
    -e "s|{{LM_BASE_URL}}|$l_esc|g" \
    -e "s|{{DATE_ISO}}|$now|g" \
    "$dest"
}

# ===== Bridge =====
start_bridge() {
  require_node18
  if _port_in_use "$BRIDGE_PORT"; then
    warn "Bridge-Port $BRIDGE_PORT bereits belegt – überspringe Start."
    return 0
  fi
  [[ -f "$BRIDGE_BIN" ]] || die "bridge.mjs nicht gefunden: $BRIDGE_BIN"
  log "Starte Bridge auf Port $BRIDGE_PORT (WORKSPACE=$WORKSPACE)…"
  nohup node "$BRIDGE_BIN" \
    --port "$BRIDGE_PORT" \
    --workspace "$WORKSPACE" \
    --allowed-tools "$SD_ALLOWED_TOOLS" \
    $( [[ -n "$SD_BYPASS_PERMISSIONS" ]] && echo "--dangerously-skip-permissions" ) \
    >>"$LOG_DIR/bridge.log" 2>&1 &
  echo $! >"$(pidfile bridge)"
  for _ in {1..20}; do
    sleep 0.25
    curl -fsS "http://127.0.0.1:$BRIDGE_PORT/healthz" >/dev/null 2>&1 && break || true
  done
}

stop_bridge() {
  if is_running bridge; then
    log "Stoppe Bridge (PID $(cat "$(pidfile bridge)") )…"
    kill "$(cat "$(pidfile bridge)")" 2>/dev/null || true
    rm -f "$(pidfile bridge)"
  fi
}

# ===== OpenHands =====
start_openhands() {
  need docker
  if docker ps --format '{{.Names}}' | grep -q "^${OH_NAME}\$"; then
    warn "OpenHands Container '$OH_NAME' läuft bereits."
    return 0
  fi
  if ! curl -fsS -m 1 "$LM_BASE_URL/models" >/dev/null 2>&1; then
    warn "LM_BASE_URL ($LM_BASE_URL) konnte nicht geprüft werden – fahre fort."
  fi

  log "Starte OpenHands ($OH_IMAGE) auf Ports GUI:$OH_PORT SEQ:$SEQ_PORT MEM:$MEM_PORT …"
  docker run -d --rm \
    --name "$OH_NAME" \
    --add-host host.docker.internal:host-gateway \
    -p "$OH_PORT:3311" -p "$SEQ_PORT:8811" -p "$MEM_PORT:8812" \
    -e LM_BASE_URL="$LM_BASE_URL" \
    -v "$WORKSPACE:/workspace" \
    "$OH_IMAGE" \
    >/dev/null

  for _ in {1..40}; do
    sleep 0.25
    curl -fsS "http://127.0.0.1:$OH_PORT" >/dev/null 2>&1 && break || true
  done
}

stop_openhands() {
  if docker ps --format '{{.Names}}' | grep -q "^${OH_NAME}\$"; then
    log "Stoppe OpenHands Container '$OH_NAME' …"
    docker rm -f "$OH_NAME" >/dev/null || true
  fi
}

open_browser() {
  local url="http://127.0.0.1:$OH_PORT"
  _open_url "$url"
  echo "GUI: $url"
}

# ===== Diagnostics =====
health() {
  banner
  local ok=0
  for url in \
    "http://127.0.0.1:$OH_PORT" \
    "http://127.0.0.1:$SEQ_PORT/healthz" \
    "http://127.0.0.1:$MEM_PORT/healthz" \
    "http://127.0.0.1:$BRIDGE_PORT/healthz"
  do
    if curl -fsS "$url" >/dev/null 2>&1; then
      echo -e "  ✓ $url"
      ok=$((ok+1))
    else
      echo -e "  ✗ $url"
    fi
  done
  [[ $ok -ge 1 ]] || return 1
}

ports_doctor() {
  echo "Port-Check:"
  for p in "$OH_PORT" "$SEQ_PORT" "$MEM_PORT" "$BRIDGE_PORT"; do
    if _port_in_use "$p"; then
      echo "  ✗ Port $p belegt:"
      _port_info "$p"
    else
      echo "  ✓ Port $p frei"
    fi
  done
}

deps_doctor() {
  echo "Dependencies:"
  for b in node npm docker npx curl; do
    if command -v "$b" >/dev/null 2>&1; then
      echo "  ✓ $b: $(command -v "$b")"
    else
      echo "  ✗ $b fehlt"
    fi
  done
  if ! groups | grep -q '\bdocker\b'; then
    echo "  ${cDim}Hinweis:${cOff} Benutzer nicht in 'docker' Gruppe – ggf. 'sudo usermod -aG docker $USER' und neu anmelden."
  fi
}

# ===== MCP / Project =====
project_init() {
  local cfg="$WORKSPACE/.claude/settings.json"
  mkdir -p "$WORKSPACE/.claude"
  if [[ -f "$cfg" ]]; then
    log "Settings vorhanden: $cfg"
  else
    cat >"$cfg" <<'JSON'
{
  "mcpServers": {
    "sequential-thinking": { "type": "sse", "url": "http://host.docker.internal:8811/sse" },
    "server-memory":       { "type": "sse", "url": "http://host.docker.internal:8812/sse" }
  }
}
JSON
    log "Minimal .claude/settings.json erzeugt."
  fi
}

mcp_status() {
  echo "MCP Status:"
  health || true
  if command -v claude >/dev/null 2>&1; then
    echo "Claude '/mcp' (gekürzt):"
    set +e
    claude -p "/mcp" --print 2>/dev/null | sed -n '1,40p'
    set -e
  else
    echo "(Hinweis) 'claude' CLI nicht gefunden – überspringe '/mcp'."
  fi
}

cmd_init_repo() {
  project_init
  ensure_oh_dirs
  [[ -f "$WORKSPACE/.openhands/index_repo.txt" ]] || : > "$WORKSPACE/.openhands/index_repo.txt"
  log "Repo initialisiert: .claude/settings.json & .openhands/"
}

# ===== Keys & LLM =====
keys_init() {
  mkdir -p "$(dirname "$ENV_FILE")"
  touch "$ENV_FILE"
  echo "API-Keys/URLs setzen (leer lassen zum Überspringen):"
  read -r -p "ANTHROPIC_API_KEY: " k1 || true
  read -r -p "LM_BASE_URL [${LM_BASE_URL}]: " k2 || true
  [[ -n "$k1" ]] && write_env_kv "ANTHROPIC_API_KEY" "$k1"
  [[ -n "$k2" ]] && write_env_kv "LM_BASE_URL" "$k2"
  echo "Gespeichert in: $ENV_FILE"
}

llm_list() {
  local url="$LM_BASE_URL/models"
  echo "Modelle von ${url}:"
  if command -v jq >/dev/null 2>&1; then
    curl -fsS "$url" | jq -r '
      (if type=="object" and has("data") then .data else . end)
      | (..|objects|select(has("id"))|.id)' | sort -u
  else
    curl -fsS "$url" || true
  fi
}

llm_use() {
  local id="${1:-}"
  [[ -n "$id" ]] || die "Usage: sd llm use <model-id>"
  write_env_kv "SD_LLM_MODEL" "$id"
  echo "SD_LLM_MODEL=$id gesetzt (in $ENV_FILE)."
}

# ===== Bridge I/O =====

send_to_bridge_file() {
  local file="$1"
  [[ -f "$file" ]] || die "Datei nicht gefunden: $file"

  # Konfiguration/Heuristik
  local endpoint="${SD_BRIDGE_ENDPOINT:-http://127.0.0.1:%s/run}"
  endpoint="$(printf "%s" "$endpoint" | sed "s|%s|$BRIDGE_PORT|g")"

  local mode="${SD_BRIDGE_PATH_MODE:-auto}"     # auto|local|container
  local fparam="${SD_BRIDGE_FILE_PARAM:-file}"  # 'file' oder 'path'
  local abs="$(_realpath "$file")"
  local cpath="/workspace${file#"$WORKSPACE"}"

  # Pfadwahl
  local chosen="$abs"
  if [[ "$mode" == "container" ]]; then
    chosen="$cpath"
  elif [[ "$mode" == "auto" ]]; then
    # Heuristik: wenn WORKSPACE im Bridge-Log mit '/workspace' erwähnt wird, nimm Container-Pfad
    if grep -q "/workspace" "$LOG_DIR/bridge.log" 2>/dev/null; then
      chosen="$cpath"
    else
      chosen="$abs"
    fi
  fi

  # Versuch 1: /run?${fparam}=chosen
  local code
  code="$(curl -sS -o /dev/null -w "%{http_code}" --get "$endpoint" --data-urlencode "${fparam}=${chosen}")" || code="000"
  if [[ "$code" == "200" ]]; then return 0; fi

  # Fallback 1: Param-Name drehen ('file' <-> 'path')
  local altparam="file"
  [[ "$fparam" == "file" ]] && altparam="path" || altparam="file"
  code="$(curl -sS -o /dev/null -w "%{http_code}" --get "$endpoint" --data-urlencode "${altparam}=${chosen}")" || code="000"
  if [[ "$code" == "200" ]]; then return 0; fi

  # Fallback 2: Pfad-Typ drehen (local <-> container)
  local altchosen="$abs"; [[ "$chosen" == "$abs" ]] && altchosen="$cpath"
  code="$(curl -sS -o /dev/null -w "%{http_code}" --get "$endpoint" --data-urlencode "${altparam}=${altchosen}")" || code="000"
  if [[ "$code" == "200" ]]; then return 0; fi

  # Fallback 3: alternativer Endpoint /run-file
  local ep2="$(printf "%s" "$endpoint" | sed 's|/run$|/run-file|')"
  code="$(curl -sS -o /dev/null -w "%{http_code}" --get "$ep2" --data-urlencode "${altparam}=${altchosen}")" || code="000"
  if [[ "$code" == "200" ]]; then return 0; fi

  die "Bridge-Aufruf fehlgeschlagen (HTTP $code). Tipp: setze SD_BRIDGE_PATH_MODE=local|container und/oder SD_BRIDGE_FILE_PARAM=file|path; prüfe $LOG_DIR/bridge.log"
}


send_to_bridge_prompt() {
  local prompt="$1"
  [[ -n "${prompt:-}" ]] || die "Leerer Prompt."
  curl -fsS --get "http://127.0.0.1:$BRIDGE_PORT/run" \
    --data-urlencode "prompt=$prompt" \
    || die "Bridge-Aufruf fehlgeschlagen."
}

# ===== Repo Helpers =====

# ===== Microagent Shortcuts =====
# bauen Prompts aus Templates, hängen optional STDIN an und senden an die Bridge
cmd_norm() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/prompts/normalize_prompt.txt"
  _render_template "microagent/normalize-user-input.md" "$f"
  if [[ -n "${SD_INPUT:-}" ]]; then
    printf "\n<raw_user_input>\n%s\n</raw_user_input>\n" "$SD_INPUT" >> "$f"
  elif [[ ! -t 0 ]]; then
    printf "\n<raw_user_input>\n%s\n</raw_user_input>\n" "$(cat)" >> "$f"
  fi
  echo -e "\n--- END_OF_PROMPT ---" >> "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_claude_init() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/prompts/init_prompt.txt"
  _render_template "microagent/send-to-claude.md" "$f"
  echo -e "\n--- END_OF_PROMPT ---" >> "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_codex_brief() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/prompts/codex_brief.txt"
  _render_template "microagent/claude-to-codex.md" "$f"
  echo -e "\n--- END_OF_CODEX_BRIEF ---" >> "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_claude_fu() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/prompts/followup_prompt.txt"
  _render_template "microagent/talk-to-claude.md" "$f"
  if [[ -n "${SD_INPUT:-}" ]]; then
    printf "\n<delta>\n%s\n</delta>\n" "$SD_INPUT" >> "$f"
  elif [[ ! -t 0 ]]; then
    printf "\n<delta>\n%s\n</delta>\n" "$(cat)" >> "$f"
  fi
  echo -e "\n--- END_OF_FOLLOWUP ---" >> "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_guardrails() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/prompts/guardrails_prompt.txt"
  _render_template "microagent/guardrails.md" "$f"
  start_bridge
  send_to_bridge_file "$f"
}

analyze() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/analyze_prompt.md"
  _render_template "analyze.md" "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_index() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/index_repo.md"
  _render_template "index.md" "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_test() {
  ensure_oh_dirs
  ( cd "$WORKSPACE" && if command -v pytest >/dev/null 2>&1; then pytest -q | tee ".openhands/test_report.txt"; else echo "pytest nicht installiert" | tee ".openhands/test_report.txt"; fi )
  local f="$WORKSPACE/.openhands/test_prompt.md"
  _render_template "test.md" "$f"
  start_bridge
  send_to_bridge_file "$f"
}

cmd_next() {
  ensure_oh_dirs
  local f="$WORKSPACE/.openhands/next_steps.md"
  _render_template "next.md" "$f"
  start_bridge
  send_to_bridge_file "$f"
}

# ===== REPL / Send Shortcuts =====
start_repl() {
  start_bridge
  echo "sd REPL — sende Zeilen an Bridge. Befehle: :quit, :help, :file <path>"
  while IFS= read -r -e line; do
    case "$line" in
      ":quit"|":q") break ;;
      ":help") echo ":file <path> — sendet Dateiinhalt /workspace-relativ"; continue ;;
      ":file "*) f="${line#:file }"; [[ -f "$f" ]] || { echo "Datei fehlt: $f"; continue; }
                 send_to_bridge_file "$(_realpath "$f")"; continue ;;
      "") continue ;;
      *) send_to_bridge_prompt "$line" ;;
    esac
  done
}

send_init() {
  local text="${*:-}"
  [[ -n "$text" ]] || die "Usage: sd send init \"GOAL: …\""
  start_bridge
  send_to_bridge_prompt "$text"
}

send_change() {
  local text="${*:-}"
  [[ -n "$text" ]] || die "Usage: sd send c \"Bitte ändere …\""
  start_bridge
  send_to_bridge_prompt "$text"
}

# ===== Usage =====
usage() {
  cat <<USAGE
$(banner)
Usage:
  sd up               # Stack im Hintergrund + Browser öffnen (GUI)
  sd start            # Stack starten & Logs im Vordergrund folgen
  sd stop             # Stack stoppen (Bridge + OpenHands)
  sd status           # Health-Checks
  sd logs             # Log-Verzeichnis anzeigen
  sd logs -f          # Logs folgen (Bridge + Docker)
  sd deps install     # Hinweise / lokale Setup-Infos
  sd deps install-global   # optionale globale CLIs installieren
  sd deps doctor      # Dependency-Check
  sd ports doctor     # Port-Check

  sd project init     # .claude/settings.json (MCP SSE) erzeugen
  sd init             # Projekt-Setup (.claude + .openhands) anlegen
  sd mcp status       # MCP-Status (healthz + ggf. 'claude -p "/mcp"')

  sd analyze          # Repo-Analyse starten
  sd index            # aktuelles Repo indexieren (Knowledge-Map)
  sd test             # Tests laufen lassen + Patch-Vorschläge
  sd next             # nächste Schritte erzeugen
  sd norm             # Nutzer-Text normalisieren → normalized_input (Prompt)
  sd claude-init      # Supervisor-Init-Prompt an Claude senden
  sd codex-brief      # Übergabe-Briefing an Codex senden
  sd claude-fu        # Follow-up (kleine Schritte) an Claude senden
  sd guardrails       # Guardrails/Policy an Claude senden


  sd keys init        # API-Keys setzen (optional)
  sd llm list         # Modelle aus LM Studio anzeigen
  sd llm use <id>     # bevorzugtes Modell merken (SD_LLM_MODEL)

  sd start-repl       # interaktive Session (GUI parallel nutzbar)
  sd send init "…"    # Initial-/Ziel-Prompt senden
  sd send c    "…"    # Änderungs-/Follow-up-Prompt senden
  sd c "…"            # Kurzform für 'sd send c …'

Env:
  ENV_FILE=$ENV_FILE
  WORKSPACE=$WORKSPACE
  Ports: OH=$OH_PORT SEQ=$SEQ_PORT MEM=$MEM_PORT BRIDGE=$BRIDGE_PORT
USAGE
}

# ===== Dispatcher =====
cmd="${1:-help}"; shift || true
case "$cmd" in
  up)            start_openhands; start_bridge; open_browser ;;
  start)         start_openhands; start_bridge; tail_logs ;;
  stop)          stop_bridge; stop_openhands ;;
  status)        health || true ;;
  logs)          if [[ "${1:-}" == "-f" ]]; then tail_logs; else echo "$LOG_DIR"; fi ;;
  deps)          sub="${1:-}"; shift || true;
                 case "${sub:-}" in
                   install)
                     echo "[sd] Lokale CLI-Dependencies werden über dieses Paket bereitgestellt."
                     echo "[sd] Optionale globale CLI:"
                     echo "     npm i -g @anthropic-ai/claude-code"
                     ;;
                   install-global)
                     npm i -g @anthropic-ai/claude-code
                     ;;
                   doctor) deps_doctor ;;
                   *) echo "Usage: sd deps {install|install-global|doctor}"; exit 2;;
                 esac ;;
  ports)         sub="${1:-}"; shift || true; [[ "${sub:-}" == "doctor" ]] && ports_doctor || usage ;;
  project)       sub="${1:-}"; shift || true; [[ "${sub:-}" == "init" ]] && project_init || usage ;;
  init)          cmd_init_repo ;;
  mcp)           sub="${1:-}"; shift || true; [[ "${sub:-}" == "status" ]] && mcp_status || usage ;;
  analyze)       analyze ;;
  index)         cmd_index ;;
  test)          cmd_test ;;
  next)          cmd_next ;;
  norm)          cmd_norm ;;
  claude-init)   cmd_claude_init ;;
  codex-brief)   cmd_codex_brief ;;
  claude-fu)     cmd_claude_fu ;;
  guardrails)    cmd_guardrails ;;

  keys)          sub="${1:-}"; shift || true; [[ "${sub:-}" == "init" ]] && keys_init || usage ;;
  llm)           sub="${1:-}"; shift || true; case "${sub:-}" in list) llm_list ;; use) llm_use "${1:-}";; *) usage ;; esac ;;
  start-repl)    start_repl ;;
  send)          sub="${1:-}"; shift || true;
                 case "${sub:-}" in
                   init) send_init "$@";;
                   c)    send_change "$@";;
                   *)    [[ -n "${sub:-}" ]] && send_to_bridge_prompt "$sub $*" || usage ;;
                 esac ;;
  c)             send_change "$@" ;;
  help|--help|-h) usage ;;
  *)             usage ;;
esac
